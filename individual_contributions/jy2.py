# Copy pasted from weile but removed the sorting part for question 3
# Change to max so it does not need to go through the list sort again to find the highest revenue
# And combinned the zip into just one as manager_revenue_pairs so dont have to do twice?
# The output is the same.


from functools import reduce
import re
import csv
from collections import Counter


def parse_CSV(path):
    read_dictionary = csv.DictReader(open(path))
    return (read_dictionary.fieldnames, list(read_dictionary))


def sanitise_data_input(entry: str):
    return " ".join(re.split("\s+", entry)).strip()


def calculate_sum(accumulator, value):
    return accumulator + value


def calculate_total_quantity(record):
    return reduce(calculate_sum, [float(entry["Quantity"]) for entry in record])


def calculate_total_revenue(record):
    if len(record) > 0:
        return reduce(
            calculate_sum,
            [float(entry["Quantity"]) * float(entry["Price"]) for entry in record],
        )
    return 0


def create_product_filter_function(product_name):
    def get_filtered_list(data):
        return list(filter(lambda record: record["Product"] == product_name, data))

    return get_filtered_list


def create_city_filter_function(city):
    def get_filtered_list(data):
        return list(filter(lambda record: record["City"] == city, data))

    return get_filtered_list


def create_manager_filter_funtion(manager):
    def get_filtered_list(data):
        return list(filter(lambda record: record["Manager"] == manager, data))

    return get_filtered_list


def create_purchase_type_filter_funtion(purchase_type):
    def get_filtered_list(data):
        return list(
            filter(lambda record: record["Purchase Type"] == purchase_type, data)
        )

    return get_filtered_list


def create_payment_method_filter_funtion(payment_method):
    def get_filtered_list(data):
        return list(
            filter(lambda record: record["Payment Method"] == payment_method, data)
        )

    return get_filtered_list


def create_date_filter_function_on_month(month):
    def get_filtered_list(data):
        return list(
            filter(lambda record: int(record["Date"][3:5]) == int(month), data)
        )  # or just compare the string?

    return get_filtered_list


def main():

    header, data = parse_CSV("restaurant_sales_data.csv")

    sanitised_data = [
        {
            sanitise_data_input(key): sanitise_data_input(value)
            for key, value in record.items()
        }
        for record in data
    ]

    # Overall Summary
    # print_list = apply_function_for_list(print)
    # map(print_list, header)
    print("Header of the dataset")
    print("---------------------")
    print(*header, sep=" | ")
    print()

    # dict of header -> set of unique values of the column
    header_to_values = {
        h: set([record[h] for record in sanitised_data]) for h in header
    }

    """ Question 3: Who is the best performing manager in terms of revenue """
    print("Analysis based on Manager")
    print("-------------------------")

    unique_manager_values = set({record["Manager"] for record in sanitised_data})
    manager_filter_function_list = list(
        map(create_manager_filter_funtion, unique_manager_values)
    )
    filtered_records_by_manager = list(
        map(lambda func: func(sanitised_data), manager_filter_function_list)
    )
    total_revenue_for_manager = list(
        map(calculate_total_revenue, filtered_records_by_manager)
    )

    manager_revenue_pairs = list(zip(unique_manager_values, total_revenue_for_manager))

    print("Managers employed by the restaurant company: ")
    print(*unique_manager_values, sep=" | ", end="\n\n")

    print("Revenue generated by each manager:")
    for manager, revenue in manager_revenue_pairs:
        print(f"{manager}: ${revenue:.2f} generated")

    best_manager = max(manager_revenue_pairs, key=lambda x: x[1])

    print("\nBest Performing Manager")
    print(
        f"{best_manager[0]} because his revenue is the highest ({best_manager[1]:.2f})"
    )


if __name__ == "__main__":
    main()
